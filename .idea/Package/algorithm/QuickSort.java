package Package.algorithm;

import java.util.Arrays;

public class QuickSort {
    public static void main(String[] args) {
        int[] testData = {8, 0, -3, 5, 6, 9, 8, -4, 2, -99, 43};

        int low = 0;                        //самый маленький индекс
        int high = testData.length - 1;     // самый большой индекс

        quickSort(testData, low, high);
        System.out.println(Arrays.toString(testData));
    }
//    Выберем некоторый опорный элемент(pivot).
//    После этого перекинем все элементы, меньшие его, налево, а большие – направо.
//    Для этого используются дополнительные переменные - значения слева и справа, которые сравниваются с pivot.
//    Рекурсивно вызовемся от каждой из частей, где будет выбран новый pivot.
//    В итоге получим отсортированный массив,
//    так как каждый элемент меньше опорного стоял раньше каждого большего опорного.

//    Асимптотика: O(n*log(n)) в среднем и лучшем случае.
//    Наихудшая оценка O(n^2) достигается при неудачном выборе опорного элемента.


    public static void quickSort(int[] array, int low, int high) {
        if (array.length == 0)
            return;                             //завершить выполнение, если длина массива равна 0

        if (low >= high)
            return;                            //завершить выполнение если уже нечего делить

        int middle = low + (high - low) / 2;   //середина= нижний индекс + (высокий-нижний) \2
        int opora = array[middle];              //выбрать опорный элемент

        int i = low, j = high;             //разделить на подмассивы, который больше и меньше опорного элемента
        while (i <= j) {                   //если нижний индекс меньше верхнего
            while (array[i] < opora) {     //если эл-т с нижним индексом меньше опоры
                i++;                        //увеличиваем индекс
            }

            while (array[j] > opora) {      //если эл-т с верхним индексом больше опоры
                j--;                           //уменьшаем индекс
            }

            if (i <= j) {                       //если эл-т с нижним индексом меньше верхнего то меняем местами
                int temp = array[i];
                array[i] = array[j];
                array[j] = temp;
                i++;
                j--;
            }
        }
                                                    //вызов рекурсии для сортировки левой и правой части
        if (low < j)
            quickSort(array, low, j);

        if (high > i)
            quickSort(array, i, high);
    }
}